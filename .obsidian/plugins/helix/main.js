/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HelixPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/codemirror-helix/dist/lib.js
var import_commands = require("@codemirror/commands");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_search = require("@codemirror/search");
var import_state2 = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var import_state3 = require("@codemirror/state");
var import_state4 = require("@codemirror/state");
var import_language = require("@codemirror/language");
var import_commands2 = require("@codemirror/commands");
var modeEffect = import_state2.StateEffect.define();
var modeField = import_state2.StateField.define({
  create() {
    return {
      type: 0,
      minor: 2
      /* Normal */
    };
  },
  update(mode, tr) {
    for (const effect of tr.effects) {
      if (effect.is(modeEffect)) {
        mode = effect.value;
      }
    }
    return mode;
  }
});
function sameMode(mode, otherMode) {
  return mode.type === otherMode.type && mode.minor === otherMode.minor;
}
function sameModeState(mode, otherMode) {
  return sameMode(mode, otherMode) && mode.count === otherMode.count && mode.expecting === otherMode.expecting;
}
function modeStatus(mode) {
  let result = "";
  if (mode.type === 1) {
    return result;
  }
  if (mode.count) {
    result += mode.count;
  }
  result += minorModeStr(mode.minor);
  if (mode.expecting) {
    result += mode.expecting.minor;
  }
  return result;
}
function minorModeStr(minor) {
  switch (minor) {
    case 2:
      return "";
    case 3:
      return "g";
    case 5:
      return "m";
    case 6:
      return "<space>";
    case 7:
      return "[";
    case 8:
      return "]";
    default: {
      if (false) {
        throw new Error("Unexpected mode");
      }
    }
  }
}
var yankEffect = import_state2.StateEffect.define();
var registersField = import_state2.StateField.define({
  create() {
    return {};
  },
  update(registers, tr) {
    for (const effect of tr.effects) {
      if (effect.is(yankEffect)) {
        if (!Array.isArray(effect.value)) {
          return effect.value.reset;
        }
        const [reg, value] = effect.value;
        if (value.length === 0) {
          const { [reg]: _reg, ...rest } = registers;
          registers = rest;
        } else {
          registers = { ...registers, [reg]: value };
        }
      }
    }
    return registers;
  }
});
var historyEffect = import_state2.StateEffect.define();
var historyField = import_state2.StateField.define({
  create() {
    return { checkpoints: [], cursor: -1, pending: null, head: null };
  },
  update(value, tr) {
    var _a, _b;
    for (const effect of tr.effects) {
      if (effect.is(historyEffect)) {
        const effectValue = effect.value;
        switch (effectValue.type) {
          case "move": {
            const cursor = value.cursor + effectValue.offset;
            value = {
              checkpoints: value.checkpoints,
              pending: null,
              cursor,
              head: (_b = (_a = value.head) != null ? _a : effectValue.head) != null ? _b : null
            };
            break;
          }
          case "add": {
            if (false) {
              if (value.pending && effectValue.temp) {
                throw new Error("Unexpected temp");
              }
            }
            const checkpoints = value.cursor === -1 ? value.checkpoints : value.checkpoints.slice(value.cursor + 1);
            value = effectValue.temp ? {
              checkpoints: value.checkpoints,
              cursor: value.cursor,
              pending: effectValue.state,
              head: value.head
            } : {
              checkpoints: [effectValue.state, ...checkpoints],
              cursor: -1,
              pending: null,
              head: null
            };
            break;
          }
          case "commit": {
            if (false) {
              if (!value.pending) {
                throw new Error("unexpected commit");
              }
            }
            if (effectValue.state.doc.eq(value.pending.doc)) {
              value = {
                ...value,
                pending: null
              };
              break;
            }
            const checkpoints = value.cursor === -1 ? value.checkpoints : value.checkpoints.slice(value.cursor + 1);
            value = {
              checkpoints: [value.pending, ...checkpoints],
              cursor: -1,
              pending: null,
              head: null
            };
            break;
          }
        }
      }
    }
    return value;
  }
});
var syntaxHistoryEffect = import_state2.StateEffect.define();
var syntaxHistoryField = import_state2.StateField.define({
  create() {
    return { selections: [], cursor: 0, head: null, frozen: false };
  },
  update(value, tr) {
    var _a;
    for (const effect of tr.effects) {
      if (effect.is(syntaxHistoryEffect)) {
        switch (effect.value.type) {
          case "freeze": {
            value = { ...value, frozen: (_a = effect.value.frozen) != null ? _a : true };
            break;
          }
          case "add": {
            value = {
              selections: [...value.selections, effect.value.prev],
              cursor: value.cursor + 1,
              head: effect.value.next,
              frozen: false
            };
            break;
          }
          case "move": {
            value = {
              ...value,
              cursor: value.cursor + effect.value.offset
            };
            break;
          }
          case "reset": {
            if (!value.frozen) {
              value = {
                frozen: false,
                selections: [],
                cursor: 0,
                head: null
              };
            }
          }
        }
      }
    }
    return value;
  }
});
function expandSyntaxHistory(state, expand, done) {
  const history = state.field(syntaxHistoryField);
  if (history.cursor < history.selections.length) {
    done({
      selection: history.cursor === history.selections.length - 1 ? history.head : history.selections[history.cursor + 1],
      effects: syntaxHistoryEffect.of({ type: "move", offset: 1 })
    });
    return;
  }
  expand(
    {
      effects: syntaxHistoryEffect.of({ type: "freeze" })
    },
    (tr) => {
      var _a;
      done(
        ((_a = tr.selection) == null ? void 0 : _a.eq(state.selection)) ? {
          effects: syntaxHistoryEffect.of({
            type: "freeze",
            frozen: false
          })
        } : {
          selection: tr.selection,
          changes: tr.changes,
          scrollIntoView: tr.scrollIntoView,
          effects: [
            ...tr.effects,
            syntaxHistoryEffect.of({
              type: "add",
              prev: state.selection,
              next: tr.newSelection
            })
          ]
        }
      );
    }
  );
}
function undoSyntaxHistory(state) {
  const history = state.field(syntaxHistoryField);
  if (history.cursor > 0) {
    return {
      selection: history.selections[history.cursor - 1],
      effects: syntaxHistoryEffect.of({ type: "move", offset: -1 })
    };
  }
}
var panelStyles = import_view2.EditorView.theme({
  ".cm-hx-status-panel": {
    display: "flex",
    "justify-content": "space-between",
    "font-family": "monospace"
  },
  ".cm-hx-command-panel": {
    display: "flex",
    justifyContent: "space-between",
    fontFamily: "monospace",
    minHeight: "18px"
  },
  ".cm-hx-command-input": {
    fontFamily: "monospace",
    fontSize: "inherit",
    border: "none",
    outline: "none",
    padding: "0",
    margin: "0",
    background: "inherit"
  },
  ".cm-hx-command-popup": {
    position: "fixed",
    background: "#ccc"
  },
  ".cm-hx-command-help": {
    border: "1px solid #777",
    background: "#ddd",
    padding: "2px",
    whiteSpace: "preserve"
  }
});
var CommandPanel = class {
  constructor(view, commandFacet, startSearch2) {
    __publicField(this, "dom");
    __publicField(this, "minorCommand");
    __publicField(this, "inputContainer");
    __publicField(this, "label");
    __publicField(this, "message", false);
    __publicField(this, "commandPopup");
    __publicField(this, "autocomplete");
    __publicField(this, "help");
    __publicField(this, "popupRequest");
    this.view = view;
    this.commandFacet = commandFacet;
    this.startSearch = startSearch2;
    this.dom = $el("div");
    this.minorCommand = $el("span");
    this.inputContainer = $el("span");
    this.commandPopup = $el("div");
    this.dom.append(this.inputContainer);
    this.dom.append(this.minorCommand);
    this.dom.append(this.commandPopup);
    this.dom.classList.add("cm-hx-command-panel");
    $style(this.inputContainer, { visibility: "hidden" });
    this.label = $el("span");
    this.inputContainer.append(this.label);
    this.commandPopup.classList.add("cm-hx-command-popup");
    this.help = $el("div");
    this.autocomplete = $el("div");
    this.help.hidden = true;
    this.help.classList.add("cm-hx-command-help");
    this.autocomplete.classList.add("cm-hx-command-autocomplete");
    this.commandPopup.append(this.help);
    this.commandPopup.append(this.autocomplete);
    $style(this.minorCommand, { minWidth: "8em", textAlign: "center " });
  }
  showSearchInput(global = false) {
    const input = this.searchInput(global);
    this.showInput(input, global ? "global-search:" : "search:");
  }
  showCommandInput() {
    const input = this.commandInput();
    this.showInput(input, ":");
  }
  showMinor(command) {
    this.minorCommand.textContent = modeStatus(command);
  }
  showInput(input, label) {
    this.label.textContent = label;
    $style(this.label, { color: "" });
    this.inputContainer.append(input);
    $style(this.inputContainer, { visibility: "" });
    input.focus();
  }
  createInput({
    onInput,
    onClose,
    placeholder
  }) {
    const input = $el("input");
    if (placeholder) {
      input.placeholder = placeholder;
    }
    input.classList.add("cm-hx-command-input");
    input.type = "text";
    let open = true;
    input.addEventListener("blur", () => {
      if (open) {
        onClose(false, input.value);
      }
    });
    input.addEventListener("input", () => {
      onInput(input.value);
    });
    input.addEventListener("keydown", (event) => {
      if (event.isComposing) {
        return;
      }
      const isEnter = event.key === "Enter";
      if (isEnter || event.key === "Escape") {
        open = false;
        onClose(isEnter, input.value);
      }
    });
    return input;
  }
  commandInput() {
    const { view } = this;
    const initialSelection = view.state.selection;
    const initialScroll = view.scrollSnapshot();
    const isNumber = (cmd) => /^\d+$/.test(cmd);
    return this.createInput({
      onClose: (commit, value) => {
        this.hidePopup();
        const [cmd, ...args] = value.split(/ +/);
        if (commit && cmd) {
          const commands2 = view.state.facet(this.commandFacet);
          const command = commands2.find(
            (command2) => {
              var _a;
              return command2.name === cmd || ((_a = command2.aliases) == null ? void 0 : _a.some((alias) => alias === cmd));
            }
          );
          const result = command ? command.handler(view, args) : {
            message: `no such command: '${cmd}'`,
            error: true
          };
          if (result) {
            this.showMessageAndCloseInput(result);
            return;
          }
        } else if (!commit && isNumber(cmd)) {
          view.dispatch({
            selection: initialSelection
          });
          setTimeout(() => {
            view.dispatch({
              effects: initialScroll
            });
          });
        }
        this.closeInput();
      },
      onInput: (value) => {
        const cmd = value.split(/ +/).at(0);
        if (!cmd) {
          this.hidePopup();
          return;
        }
        if (isNumber(cmd)) {
          const lineNo = Number(cmd);
          if (lineNo >= 1 && lineNo <= view.state.doc.lines) {
            const line = view.state.doc.line(lineNo);
            view.dispatch({
              selection: import_state3.EditorSelection.cursor(line.from),
              effects: import_view2.EditorView.scrollIntoView(line.from, { y: "center" })
            });
          }
          return;
        }
        const commands2 = view.state.facet(this.commandFacet);
        const options = commands2.filter(
          (command) => {
            var _a;
            return command.name.startsWith(cmd) || ((_a = command.aliases) == null ? void 0 : _a.some((alias) => alias.startsWith(cmd)));
          }
        );
        if (options.length === 0) {
          this.hidePopup();
          return;
        }
        const match = options.find(
          (command) => {
            var _a;
            return command.name === cmd || ((_a = command.aliases) == null ? void 0 : _a.some((alias) => alias === cmd));
          }
        );
        this.showPopup(options, match);
      }
    });
  }
  showError(message) {
    this.showMessage({ message, error: true });
  }
  showMessage(messageOrResult) {
    if (messageOrResult == null) {
      return;
    }
    const [message, error] = typeof messageOrResult === "string" ? [messageOrResult, false] : [messageOrResult.message, messageOrResult.error];
    $style(this.inputContainer, { visibility: "" });
    this.message = true;
    $style(this.label, { color: error ? "red" : "" });
    this.label.textContent = message;
  }
  showMessageAndCloseInput(result) {
    this.showMessage(result);
    this.closeInput(!result);
  }
  hasMessage() {
    return this.message;
  }
  clearMessage() {
    if (this.message) {
      this.message = false;
      this.label.textContent = "";
      $style(this.inputContainer, { visibility: "hidden" });
    }
  }
  showPopup(commands2, match) {
    var _a;
    this.commandPopup.hidden = false;
    this.help.hidden = !match;
    if (match) {
      this.help.textContent = `${match.help}`;
      if (match.aliases && match.aliases.length > 0) {
        this.help.textContent += `
Aliases: ${match.aliases.join(",")}`;
      }
    } else {
      this.help.textContent = "";
    }
    while (commands2.length > this.autocomplete.childNodes.length) {
      const entry = $el("span");
      $style(entry, { marginRight: "1em" });
      this.autocomplete.append(entry);
    }
    for (const [i, child] of this.autocomplete.childNodes.entries()) {
      const command = commands2[i];
      if (command) {
        child.textContent = command.name;
      } else {
        break;
      }
    }
    while (this.autocomplete.childNodes.length > commands2.length) {
      (_a = this.autocomplete.lastChild) == null ? void 0 : _a.remove();
    }
    if (this.popupRequest == null) {
      this.popupRequest = requestAnimationFrame(() => this.positionPopup());
    }
  }
  hidePopup() {
    this.commandPopup.hidden = true;
  }
  positionPopup() {
    this.popupRequest = void 0;
    if (this.commandPopup.hidden) {
      return;
    }
    const box = this.inputContainer.getBoundingClientRect();
    $style(this.commandPopup, {
      bottom: `${window.innerHeight - box.top}px`,
      left: `${box.left}px`
    });
  }
  searchInput(global) {
    const search = this.startSearch(global);
    return this.createInput({
      placeholder: search.init,
      onClose: (commit) => {
        this.showMessageAndCloseInput(search.onClose(commit));
      },
      onInput: (value) => {
        search.onInput(value);
      }
    });
  }
  closeInput(hide = true) {
    this.inputContainer.removeChild(this.inputContainer.lastChild);
    if (hide) {
      $style(this.inputContainer, { visibility: "hidden" });
    }
    requestAnimationFrame(() => {
      this.view.focus();
    });
  }
};
function statusPanel(view) {
  const dom = $el("div");
  dom.classList.add("cm-hx-status-panel");
  const mode = $el("span");
  mode.textContent = "NOR";
  dom.append(mode);
  const pos = $el("span");
  dom.append(pos);
  function setLineCol() {
    const { line, column } = lineCol(view);
    pos.textContent = `${line}:${column}`;
  }
  setLineCol();
  return {
    dom,
    setMode(modeStr) {
      mode.textContent = modeStr;
    },
    setLineCol
  };
}
function lineCol(view) {
  const head = view.state.selection.main.head;
  const lineDesc = view.state.doc.lineAt(head);
  const line = lineDesc.number;
  const column = head - lineDesc.from + 1;
  return { line, column };
}
function $el(tag) {
  return document.createElement(tag);
}
function $style(el, styles) {
  Object.assign(el.style, styles);
}
var MODE_EFF = {
  NORMAL: modeEffect.of({
    type: 0,
    minor: 2
    /* Normal */
  }),
  NORMAL_GOTO: modeEffect.of({
    type: 0,
    minor: 3
    /* Goto */
  }),
  NORMAL_MATCH: modeEffect.of({
    type: 0,
    minor: 5
    /* Match */
  }),
  NORMAL_SPACE: modeEffect.of({
    type: 0,
    minor: 6
    /* Space */
  }),
  SELECT: modeEffect.of({
    type: 4,
    minor: 2
    /* Normal */
  }),
  SELECT_GOTO: modeEffect.of({
    type: 4,
    minor: 3
    /* Goto */
  }),
  SELECT_MATCH: modeEffect.of({
    type: 4,
    minor: 5
    /* Match */
  }),
  SELECT_SPACE: modeEffect.of({
    type: 4,
    minor: 6
    /* Space */
  }),
  INSERT: modeEffect.of({
    type: 1
    /* Insert */
  })
};
function moveByChar(view, mode, forward) {
  const initial = view.state.selection.main;
  const select = mode.type === 4;
  const next = select ? selectByChar(view, mode, forward) : cursorByChar(view, mode, forward);
  if (initial.eq(next)) {
    return false;
  }
  view.dispatch({
    selection: next,
    effects: resetCount(mode),
    scrollIntoView: true
  });
  return true;
}
function withHelixSelection(view, command) {
  view.dispatch({
    selection: cmSelToInternal(view.state.selection.main, view.state.doc)
  });
  const result = command(view);
  view.dispatch({
    selection: internalSelToCM(view.state.selection.main, view.state.doc)
  });
  return result;
}
function cmSelToInternal(range, doc) {
  var _a;
  if (range.empty) {
    return range;
  }
  const end = nextClusterBreak(doc, range.to, false);
  const [anchor, head] = rangeForward(range) ? [range.from, end] : [end, range.from];
  return import_state4.EditorSelection.range(
    anchor,
    head,
    range.goalColumn,
    (_a = range.bidiLevel) != null ? _a : void 0
  );
}
function removeText(view, { yank, edit } = {}) {
  const selection = view.state.selection.main;
  const effects = [];
  yank != null ? yank : yank = true;
  if (yank) {
    effects.push(
      yankEffect.of([`"`, view.state.doc.slice(selection.from, selection.to)])
    );
  }
  if (edit) {
    effects.push(MODE_EFF.INSERT);
  }
  view.dispatch({
    effects,
    changes: {
      from: selection.from,
      to: selection.to,
      insert: ""
    }
  });
  if (!edit && view.state.selection.main.empty) {
    view.dispatch({
      selection: internalSelToCM(view.state.selection.main, view.state.doc)
    });
  }
}
function internalSelToCM(range, doc) {
  var _a;
  const end = nextClusterBreak(doc, range.to, true);
  const [anchor, head] = rangeForward(range) ? [range.from, end] : [end, range.from];
  return import_state4.EditorSelection.range(
    anchor,
    head,
    range.goalColumn,
    (_a = range.bidiLevel) != null ? _a : void 0
  );
}
function cursorToLineStart(view, mode) {
  const isNormal = mode.type === 0;
  withHelixSelection(
    view,
    (view2) => isNormal ? (0, import_commands2.cursorLineStart)(view2) : (0, import_commands2.selectLineStart)(view2)
  );
  view.dispatch({
    effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT
  });
}
function cursorToLineEnd(view, mode) {
  const select = mode.type === 4;
  const selection = cmSelToInternal(view.state.selection.main, view.state.doc);
  const line = view.state.doc.lineAt(selection.head);
  if (line.length === 0) {
    return false;
  }
  const goal = nextClusterBreak(view.state.doc, line.to, false);
  const next = select ? import_state4.EditorSelection.range(selection.anchor, goal, selection.goalColumn) : import_state4.EditorSelection.cursor(goal, void 0, void 0, selection.goalColumn);
  view.dispatch({
    selection: internalSelToCM(next, view.state.doc),
    effects: select ? MODE_EFF.SELECT : MODE_EFF.NORMAL
  });
  return true;
}
function cursorByChar(view, mode, forward) {
  const doc = view.state.doc;
  const count = cmdCount(mode);
  const selection = view.state.selection.main;
  let counter = count;
  const by = count > 1 ? () => () => {
    counter--;
    return counter > 0;
  } : void 0;
  const cursor = cmSelToInternal(selection, doc).head;
  const moved = view.moveByChar(import_state4.EditorSelection.cursor(cursor), forward, by);
  return internalSelToCM(import_state4.EditorSelection.cursor(moved.head), doc);
}
function selectByChar(view, mode, forward) {
  const doc = view.state.doc;
  const count = cmdCount(mode);
  const initial = cmSelToInternal(view.state.selection.main, doc);
  let counter = count;
  const by = count > 1 ? () => () => {
    counter--;
    return counter > 0;
  } : void 0;
  const next = view.moveByChar(
    import_state4.EditorSelection.cursor(initial.head),
    forward,
    by
  );
  return internalSelToCM(import_state4.EditorSelection.range(initial.anchor, next.head), doc);
}
function selectByLine(view, mode, forward) {
  const doc = view.state.doc;
  const count = cmdCount(mode);
  const initial = cmSelToInternal(view.state.selection.main, doc);
  let selection = initial;
  for (let _i = 0; _i < count; _i++) {
    selection = view.moveVertically(
      import_state4.EditorSelection.cursor(
        selection.head,
        void 0,
        void 0,
        selection.goalColumn
      ),
      forward
    );
  }
  return internalSelToCM(
    import_state4.EditorSelection.range(initial.anchor, selection.head, selection.goalColumn),
    doc
  );
}
function cursorByLine(view, mode, forward) {
  const doc = view.state.doc;
  const count = cmdCount(mode);
  const initial = view.state.selection.main;
  const selection = cmSelToInternal(initial, doc);
  let cursor = selection.head;
  let goalColumn = selection.goalColumn;
  for (let _i = 0; _i < count; _i++) {
    const line = doc.lineAt(cursor).number;
    if (forward && line === doc.lines || !forward && line === 1) {
      break;
    }
    const next = view.moveVertically(
      import_state4.EditorSelection.cursor(cursor, void 0, void 0, goalColumn),
      forward
    );
    cursor = next.to;
    goalColumn = next.goalColumn;
  }
  return internalSelToCM(
    import_state4.EditorSelection.cursor(cursor, void 0, void 0, goalColumn),
    doc
  );
}
function moveByHalfPage(view, mode, forward) {
  const select = mode.type === 4;
  const next = select ? selectByHalfPage(view, forward) : cursorByHalfPage(view, forward);
  if (next.eq(view.state.selection.main)) {
    return false;
  }
  view.dispatch({
    selection: import_state4.EditorSelection.create([next]),
    scrollIntoView: true
  });
}
function cursorByHalfPage(view, forward) {
  const doc = view.state.doc;
  const selection = cmSelToInternal(view.state.selection.main, doc);
  const lineBlock = view.lineBlockAt(doc.lineAt(selection.head).from);
  const end = view.lineBlockAt(forward ? doc.length : 0);
  const height = Math.min(
    view.scrollDOM.clientHeight / 2,
    Math.abs(lineBlock.top - end.top)
  );
  if (height < 1) {
    return view.state.selection.main;
  }
  const next = view.moveVertically(
    import_state4.EditorSelection.cursor(
      selection.head,
      void 0,
      void 0,
      selection.goalColumn
    ),
    forward,
    height
  );
  return internalSelToCM(next, doc);
}
function selectByHalfPage(view, forward) {
  const doc = view.state.doc;
  const selection = cmSelToInternal(view.state.selection.main, doc);
  const lineBlock = view.lineBlockAt(doc.lineAt(selection.head).from);
  const end = view.lineBlockAt(forward ? doc.length : 0);
  const height = Math.min(
    view.scrollDOM.clientHeight / 2,
    Math.abs(lineBlock.top - end.top)
  );
  if (height < 1) {
    return view.state.selection.main;
  }
  const next = view.moveVertically(
    import_state4.EditorSelection.cursor(
      selection.head,
      void 0,
      void 0,
      selection.goalColumn
    ),
    forward,
    height
  );
  return internalSelToCM(
    import_state4.EditorSelection.range(selection.anchor, next.head, next.goalColumn),
    doc
  );
}
function moveByLine(view, mode, forward) {
  const select = mode.type === 4;
  const initial = view.state.selection.main;
  const next = select ? selectByLine(view, mode, forward) : cursorByLine(view, mode, forward);
  if (initial.eq(next)) {
    return false;
  }
  view.dispatch({
    selection: import_state4.EditorSelection.create([next]),
    effects: resetCount(mode),
    scrollIntoView: true
  });
  return true;
}
function moveDown(view, mode) {
  return moveByLine(view, mode, true);
}
function moveUp(view, mode) {
  return moveByLine(view, mode, false);
}
function moveLeft(view, mode) {
  moveByChar(view, mode, false);
}
function moveRight(view, mode) {
  moveByChar(view, mode, true);
}
function setFindMode(view, status, mode, metadata) {
  const effect = modeEffect.of({
    type: mode.type,
    minor: 2,
    count: mode.count,
    expecting: {
      minor: status,
      callback: findText,
      metadata
    }
  });
  view.dispatch({ effects: effect });
}
function findText(view, text, {
  inclusive,
  forward
}) {
  const mode = view.state.field(modeField);
  const count = mode.type === 1 ? 1 : cmdCount(mode);
  const select = mode.type === 4;
  const selection = cmSelToInternal(view.state.selection.main, view.state.doc);
  const doc = view.state.doc;
  const start = selection.head;
  const docString = doc.sliceString(0);
  let rawIndex = start;
  for (let _i = 0; _i < count; _i++) {
    if (!forward && rawIndex === 0) {
      rawIndex = -1;
      break;
    }
    rawIndex = forward ? docString.indexOf(text, rawIndex + 1) : docString.lastIndexOf(text, rawIndex - 1);
    if (rawIndex < 0) {
      break;
    }
  }
  const resetEffect = select ? MODE_EFF.SELECT : MODE_EFF.NORMAL;
  if (rawIndex === -1) {
    view.dispatch({
      effects: resetEffect
    });
    return;
  }
  const index = inclusive ? rawIndex : forward ? rawIndex - 1 : rawIndex + 1;
  const newSelection = select ? import_state4.EditorSelection.range(selection.anchor, index) : import_state4.EditorSelection.range(selection.head, index);
  view.dispatch({
    effects: resetEffect,
    selection: internalSelToCM(newSelection, doc)
  });
}
function moveToSibling(view, forward) {
  const tree = (0, import_language.syntaxTree)(view.state);
  const selection = view.state.selection.main;
  let stack = tree.resolveStack(selection.from, 1);
  let sibling = null;
  while (true) {
    const node = stack.node;
    if (node && node.from <= selection.from && node.to >= selection.to) {
      sibling = forward ? node == null ? void 0 : node.nextSibling : node == null ? void 0 : node.prevSibling;
      if (sibling) {
        break;
      }
    }
    if (stack.next) {
      stack = stack.next;
    } else {
      break;
    }
  }
  if (!sibling) {
    view.dispatch({
      selection: import_state4.EditorSelection.range(0, view.state.doc.length),
      scrollIntoView: true
    });
    return;
  }
  view.dispatch({
    selection: import_state4.EditorSelection.range(sibling.from, sibling.to),
    scrollIntoView: true
  });
}
var PAIRS = {
  "(": ["(", ")", true],
  ")": ["(", ")", false],
  "{": ["{", "}", true],
  "}": ["{", "}", false],
  "[": ["[", "]", true],
  "]": ["[", "]", false],
  "<": ["<", ">", true],
  ">": ["<", ">", false]
};
var MATCHEABLE = /* @__PURE__ */ new Set([...Object.keys(PAIRS), `"`, "'"]);
function matchBracket(view) {
  var _a, _b;
  const selection = view.state.selection.main;
  const char = view.state.doc.sliceString(selection.head, selection.head + 1);
  if (!MATCHEABLE.has(char)) {
    return null;
  }
  const open = (_b = (_a = PAIRS[char]) == null ? void 0 : _a[2]) != null ? _b : false;
  const match = (0, import_language.matchBrackets)(
    view.state,
    selection.head + (open ? 0 : 1),
    open ? 1 : -1
  );
  if (match) {
    return match.end;
  }
}
function surround(view, char, proxy) {
  var _a, _b;
  const pair = PAIRS[char];
  const selection = view.state.selection.main;
  const open = (_a = pair == null ? void 0 : pair[0]) != null ? _a : char;
  const close = (_b = pair == null ? void 0 : pair[1]) != null ? _b : char;
  view.dispatch({
    changes: [
      {
        from: selection.from,
        insert: open
      },
      {
        from: selection.to,
        insert: close
      }
    ],
    effects: MODE_EFF.NORMAL
  });
  const newSelection = proxy.original.state.selection.main;
  const offset = newSelection.anchor === newSelection.from ? 1 : -1;
  const anchor = newSelection.anchor - offset;
  const head = newSelection.head + offset;
  proxy.original.dispatch({
    selection: import_state4.EditorSelection.range(anchor, head)
  });
}
function replaceWithChar(_, char, view) {
  const selection = view.state.selection.main;
  const selected = view.state.doc.sliceString(selection.from, selection.to);
  let len = 0;
  let offset = 0;
  while (true) {
    const next = (0, import_state4.findClusterBreak)(selected, offset, true);
    if (next === offset) {
      break;
    }
    offset = next;
    len++;
  }
  view.dispatch({
    changes: {
      from: selection.from,
      to: selection.to,
      insert: char.repeat(len)
    },
    effects: MODE_EFF.NORMAL
  });
}
function changeCase(view, upper) {
  const selection = view.state.selection.main;
  const selected = view.state.doc.sliceString(selection.from, selection.to);
  let insert;
  if (upper == null) {
    insert = [...selected].map((char) => {
      let next = char.toUpperCase();
      return next === char ? char.toLowerCase() : next;
    }).join("");
  } else if (upper) {
    insert = selected.toUpperCase();
  } else {
    insert = selected.toLowerCase();
  }
  view.dispatch({
    changes: {
      from: selection.from,
      to: selection.to,
      insert
    }
  });
}
function paste(view, yanked, before, count, reset = true) {
  const range = view.state.selection.main;
  yanked != null ? yanked : yanked = "";
  const spec = { from: range.to, insert: yanked.toString().repeat(count) };
  const change = view.state.changes(spec);
  view.dispatch(
    { changes: change },
    {
      selection: before ? { anchor: range.to, head: range.to + yanked.length } : { anchor: range.from, head: range.from + yanked.length },
      sequential: true
    },
    reset ? { effects: MODE_EFF.NORMAL } : {}
  );
}
function openLine(view, below) {
  let from;
  let cursor;
  const selection = cmSelToInternal(view.state.selection.main, view.state.doc);
  if (below) {
    const line = view.state.doc.lineAt(selection.to);
    from = line.to;
    cursor = from + view.state.lineBreak.length;
  } else {
    const line = view.state.doc.lineAt(selection.from);
    from = line.from;
    cursor = from;
  }
  view.dispatch({
    changes: {
      from,
      insert: view.state.lineBreak
    },
    selection: import_state4.EditorSelection.cursor(cursor),
    effects: MODE_EFF.INSERT
  });
}
var countCommands = Object.fromEntries(
  Array.from({ length: 10 }, (_, count) => [
    String(count),
    (view, mode) => {
      const next = mode.count != null ? mode.count * 10 + count : count;
      if (next === 0) {
        return;
      }
      view.dispatch({
        effects: modeEffect.of({ ...mode, count: next })
      });
    }
  ])
);
function insertLine(view, below) {
  const mode = view.state.field(modeField);
  const count = mode.type === 1 ? 1 : cmdCount(mode);
  const select = mode.type === 4;
  const selection = view.state.selection.main;
  const line = view.state.doc.lineAt(below ? selection.to : selection.from);
  const changes = {
    from: below ? line.to : line.from,
    insert: view.state.lineBreak.repeat(count)
  };
  const resetEffect = select ? MODE_EFF.SELECT : MODE_EFF.NORMAL;
  view.dispatch({ changes, effects: resetEffect });
}
function cmdCount(mode) {
  var _a;
  return (_a = mode.count) != null ? _a : 1;
}
function resetCount(mode) {
  const { count: _count, ...rest } = mode;
  return modeEffect.of(rest);
}
function rangeForward(range) {
  return range.head > range.from;
}
function atomicRange(range, doc) {
  const len = range.to - range.from;
  if (len <= 1) {
    return true;
  } else if (len === 2) {
    const charCode = doc.sliceString(range.from, range.to).charCodeAt(0);
    return charCode >= 55296 && charCode <= 57343;
  } else {
    return false;
  }
}
function nextClusterBreak(doc, pos, forward) {
  if (!forward && pos === 0 || forward && pos === doc.length) {
    return pos;
  }
  const line = doc.lineAt(pos);
  if (forward && line.to === pos) {
    return pos + 1;
  } else if (!forward && line.from === pos) {
    return pos - 1;
  }
  return (0, import_state4.findClusterBreak)(line.text, pos - line.from, forward) + line.from;
}
function backwardsSearch(state, query, mode, select) {
  const cursor = query.getCursor(state);
  const selection = state.selection.main;
  const count = cmdCount(mode);
  const beforeRing = new Ring(count);
  const iter = peekable(cloned(cursor));
  const beforeIter = peekingUntil(iter, (item) => item.to >= selection.from);
  for (const item of {
    [Symbol.iterator]() {
      return beforeIter;
    }
  }) {
    beforeRing.push(item);
  }
  if (beforeRing.length === count) {
    select(beforeRing.first);
    return;
  }
  const afterRing = new Ring(count - beforeRing.length);
  for (const item of {
    [Symbol.iterator]() {
      return iter;
    }
  }) {
    afterRing.push(item);
  }
  const total = afterRing.length + beforeRing.length;
  if (total === 0) {
    return {
      match: false
    };
  }
  if (total === count) {
    select(afterRing.first);
    return {
      wrapped: true
    };
  }
  const all = [...beforeRing, ...afterRing];
  const rem = count % total;
  select(all[all.length - rem - 1]);
  return {
    wrapped: true
  };
}
var Ring = class {
  constructor(length) {
    __publicField(this, "items");
    __publicField(this, "head");
    __publicField(this, "length");
    __publicField(this, "maxLength");
    this.items = Array.from({ length });
    this.maxLength = length;
    this.head = 0;
    this.length = 0;
  }
  get first() {
    return this.items[this.start];
  }
  push(item) {
    this.items[this.head] = item;
    this.head += 1;
    this.length += 1;
    this.head %= this.maxLength;
    this.length = Math.min(this.maxLength, this.length);
  }
  merge(other) {
    for (let i = 0; i < other.length; i++) {
      const item = other.items[(other.start + i) % other.maxLength];
      this.push(item);
    }
  }
  *[Symbol.iterator]() {
    for (let i = 0; i < this.length; i++) {
      yield this.items[(this.start + i) % this.maxLength];
    }
  }
  get start() {
    if (this.length < this.maxLength) {
      return 0;
    } else {
      return (this.head + 1) % this.maxLength;
    }
  }
};
function peekingUntil(iter, check) {
  return {
    next() {
      const item = iter.peek();
      if (item.done) {
        return item;
      }
      if (check(item.value)) {
        return { value: void 0, done: true };
      }
      return iter.next();
    }
  };
}
function peekable(iter) {
  let next = iter.next();
  const peekIter = {
    next() {
      const item = next;
      if (!item.done) {
        next = iter.next();
      }
      return item;
    },
    peek() {
      return next;
    }
  };
  return peekIter;
}
function cloned(iter) {
  return {
    next() {
      return { ...iter.next() };
    }
  };
}
function startSearch(view, global) {
  var _a, _b;
  const initialScroll = view.scrollSnapshot();
  const initialSelection = view.state.selection;
  let input = "";
  let query = null;
  function reset() {
    view.dispatch({
      selection: initialSelection
    });
    resetScroll(view, initialScroll);
  }
  return {
    init: (_b = (_a = view.state.field(registersField)["/"]) == null ? void 0 : _a.toString()) != null ? _b : "",
    onInput(input_) {
      if (input !== input_) {
        input = input_;
        query = searchQuery(input);
      } else {
        return;
      }
      if (!(query == null ? void 0 : query.valid)) {
        return;
      }
      if (global) {
        return;
      }
      let match = query.getCursor(view.state, initialSelection.main.to).next();
      if (match.done) {
        match = query.getCursor(view.state).next();
      }
      if (match.done) {
        reset();
      } else {
        const selection = import_state.EditorSelection.range(
          match.value.from,
          match.value.to
        );
        view.dispatch({
          selection,
          effects: import_view.EditorView.scrollIntoView(selection, { y: "center" })
        });
      }
    },
    onClose(accept) {
      var _a2;
      if (!accept) {
        reset();
        return;
      }
      if (input != null) {
        view.dispatch({
          effects: yankEffect.of(["/", input])
        });
      }
      if (global) {
        const externalCommands = view.state.facet(externalCommandsFacet);
        const query2 = input || view.state.field(registersField)["/"];
        if (query2) {
          return (_a2 = externalCommands.global_search) == null ? void 0 : _a2.call(externalCommands, query2.toString());
        }
      }
    }
  };
}
function searchQuery(query) {
  return new import_search.SearchQuery({
    search: query,
    regexp: true,
    caseSensitive: /[A-Z]/.test(query)
  });
}
var searchFacet = import_state.Facet.define({
  combine(inputs) {
    const input = inputs[0];
    return input ? searchQuery(input) : void 0;
  }
});
var helixCommandBindings = {
  insert: {
    Backspace(view) {
      (0, import_commands.deleteCharBackward)(view);
    },
    Delete(view) {
      (0, import_commands.deleteCharForward)(view);
    },
    Enter(view) {
      (0, import_commands.insertNewlineAndIndent)(view);
    },
    // we need these two due to https://github.com/codemirror/dev/issues/634
    // FIXME: stuff like Shift-<arrow> doesn't quite work with `editor.cursor-shape.insert === "block"`.
    ArrowLeft: import_commands.cursorCharLeft,
    ArrowRight: import_commands.cursorCharRight,
    Escape(view) {
      let selection = view.state.selection.main;
      if (selection.empty) {
        selection = internalSelToCM(selection, view.state.doc);
      }
      view.dispatch({
        effects: [
          MODE_EFF.NORMAL,
          historyEffect.of({ type: "commit", state: view.state })
        ],
        selection
      });
    }
  },
  normal: {
    // this one is special: we let it apply to all other minor modes
    Escape(view, mode_) {
      const mode = mode_;
      if (mode.type === 0 && mode.minor === 2 && mode.expecting == null && mode.count == null) {
        return true;
      }
      view.dispatch({
        effects: [MODE_EFF.NORMAL]
      });
    },
    ["/"](view) {
      const panel = getCommandPanel(view);
      panel.showSearchInput();
    },
    ...countCommands,
    [":"](view, mode) {
      view.dispatch({
        effects: modeEffect.of({ ...mode, count: void 0 })
      });
      getCommandPanel(view).showCommandInput();
    },
    ["y"](view) {
      const selection = view.state.selection.main;
      view.dispatch({
        effects: yankEffect.of([
          `"`,
          view.state.doc.slice(selection.from, selection.to)
        ])
      });
      getCommandPanel(view).showMessage('yanked 1 selection to register "');
    },
    ["a"]: {
      checkpoint: "temp",
      command(view) {
        const selection = view.state.selection.main;
        view.dispatch({
          effects: MODE_EFF.INSERT,
          selection: import_state.EditorSelection.cursor(selection.to)
        });
      }
    },
    ["A"]: {
      checkpoint: "temp",
      command(view) {
        const selection = view.state.selection.main;
        const end = view.state.doc.lineAt(selection.to).to;
        view.dispatch({
          effects: MODE_EFF.INSERT,
          selection: import_state.EditorSelection.cursor(end)
        });
      }
    },
    ["I"]: {
      checkpoint: "temp",
      command(view) {
        const selection = view.state.selection.main;
        const start = view.state.doc.lineAt(selection.from).from;
        view.dispatch({
          effects: MODE_EFF.INSERT,
          selection: import_state.EditorSelection.cursor(start)
        });
      }
    },
    ["c"]: {
      checkpoint: "temp",
      command(view) {
        removeText(view, { edit: true });
      }
    },
    ["d"]: {
      checkpoint: true,
      command(view) {
        removeText(view);
      }
    },
    ["Alt-c"]: {
      checkpoint: "temp",
      command(view) {
        removeText(view, { yank: false, edit: true });
      }
    },
    ["Alt-d"]: {
      checkpoint: true,
      command(view) {
        removeText(view, { yank: false });
      }
    },
    ["P"]: {
      checkpoint: true,
      command(view, mode) {
        const yanked = view.state.field(registersField);
        paste(view, yanked[`"`], false, cmdCount(mode));
      }
    },
    ["p"]: {
      checkpoint: true,
      command(view, mode) {
        const yanked = view.state.field(registersField);
        paste(view, yanked[`"`], true, cmdCount(mode));
      }
    },
    ["R"]: {
      checkpoint: true,
      command(view, mode) {
        var _a;
        const contents = (_a = view.state.field(registersField)[`"`]) != null ? _a : "";
        const count = cmdCount(mode);
        const replacement = count === 1 ? contents : contents.toString().repeat(count);
        const tr = view.state.replaceSelection(replacement);
        tr.effects = MODE_EFF.NORMAL;
        view.dispatch(tr);
      }
    },
    ["r"]: {
      checkpoint: true,
      command(view, mode) {
        view.dispatch({
          effects: modeEffect.of({
            ...mode,
            expecting: {
              minor: "r",
              callback: replaceWithChar,
              metadata: view
            }
          })
        });
      }
    },
    ["w"](view, mode) {
      if (mode.type === 0) {
        const current = view.state.selection.main;
        view.dispatch({
          selection: import_state.EditorSelection.single(Math.max(current.from, current.to))
        });
      }
      for (let _i = 0; _i < cmdCount(mode); _i++) {
        (0, import_commands.selectGroupRight)(view);
      }
    },
    ["b"](view, mode) {
      if (mode.type === 0) {
        const current = view.state.selection.main;
        view.dispatch({
          selection: import_state.EditorSelection.single(Math.min(current.from, current.to))
        });
      }
      for (let _i = 0; _i < cmdCount(mode); _i++) {
        (0, import_commands.selectGroupLeft)(view);
      }
    },
    ["v"](view, mode) {
      view.dispatch({
        effects: mode.type === 0 ? MODE_EFF.SELECT : MODE_EFF.NORMAL
      });
    },
    ["g"](view, mode) {
      const isNormal = mode.type === 0;
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL_GOTO : MODE_EFF.SELECT_GOTO
      });
    },
    ["Space"](view, mode) {
      const isNormal = mode.type === 0;
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL_SPACE : MODE_EFF.SELECT_SPACE
      });
    },
    ["m"](view, mode) {
      const isNormal = mode.type === 0;
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL_MATCH : MODE_EFF.SELECT_MATCH
      });
    },
    ["i"]: {
      checkpoint: "temp",
      command(view) {
        const selection = view.state.selection.main;
        const cursor = Math.min(selection.from, selection.to);
        view.dispatch({
          effects: MODE_EFF.INSERT,
          selection: import_state.EditorSelection.cursor(cursor)
        });
      }
    },
    ["h"](view, mode) {
      return moveLeft(view, mode);
    },
    ["j"]: moveDown,
    ["ArrowDown"]: "j",
    ["ArrowUp"]: "k",
    ["k"]: moveUp,
    ["ArrowRight"]: "l",
    ["ArrowLeft"]: "h",
    ["l"](view, mode) {
      return moveRight(view, mode);
    },
    ["%"](view) {
      return (0, import_commands.selectAll)(view);
    },
    ["o"]: {
      checkpoint: "temp",
      command(view) {
        openLine(view, true);
      }
    },
    ["O"]: {
      checkpoint: "temp",
      command(view) {
        openLine(view, false);
      }
    },
    ["f"](view, mode) {
      setFindMode(view, "f", mode, {
        inclusive: true,
        forward: true
      });
    },
    ["F"](view, mode) {
      setFindMode(view, "F", mode, {
        inclusive: true,
        forward: false
      });
    },
    ["t"](view, mode) {
      setFindMode(view, "t", mode, {
        inclusive: false,
        forward: true
      });
    },
    ["T"](view, mode) {
      setFindMode(view, "T", mode, {
        inclusive: false,
        forward: false
      });
    },
    ["u"](view, mode) {
      const { checkpoints, cursor } = view.state.field(historyField);
      const nextCursor = cursor + cmdCount(mode);
      const state = checkpoints[nextCursor];
      if (!state) {
        return true;
      }
      view.dispatch({
        changes: {
          from: 0,
          to: view.state.doc.length,
          insert: state.doc
        },
        selection: state.selection,
        effects: [
          historyEffect.of({
            type: "move",
            offset: cmdCount(mode),
            head: view.state
          }),
          resetCount(mode)
        ],
        scrollIntoView: true
      });
    },
    ["U"](view, mode) {
      const { checkpoints, cursor, head } = view.state.field(historyField);
      const nextCursor = cursor - cmdCount(mode);
      const state = nextCursor === -1 ? head : checkpoints[nextCursor];
      if (!state) {
        return true;
      }
      view.dispatch({
        changes: {
          from: 0,
          to: view.state.doc.length,
          insert: state.doc
        },
        selection: state.selection,
        effects: [
          historyEffect.of({
            type: "move",
            offset: -cmdCount(mode)
          }),
          resetCount(mode)
        ],
        scrollIntoView: true
      });
    },
    ["x"](view, mode) {
      const initial = view.state.selection.main;
      const startLine = view.state.doc.lineAt(initial.from);
      let endLine = view.state.doc.lineAt(initial.to);
      if (!initial.empty && initial.to === endLine.from) {
        endLine = view.state.doc.line(endLine.number - 1);
      }
      const ideal = import_state.EditorSelection.range(
        startLine.from,
        Math.min(
          view.state.doc.length,
          endLine.to + view.state.lineBreak.length
        )
      );
      let nextSel;
      const perfectLineSelection = ideal.from === initial.from && ideal.to === initial.to;
      if (perfectLineSelection || mode.count) {
        const nextLineNumber = Math.min(
          endLine.number + cmdCount(mode),
          view.state.doc.lines
        );
        const nextLine = view.state.doc.line(nextLineNumber);
        nextSel = import_state.EditorSelection.range(
          startLine.from,
          Math.min(
            view.state.doc.length,
            nextLine.to + view.state.lineBreak.length
          )
        );
      } else {
        nextSel = ideal;
      }
      view.dispatch({
        selection: nextSel,
        effects: resetCount(mode)
      });
      return true;
    },
    ["n"](view, mode) {
      const query = view.state.facet(searchFacet);
      if (!(query == null ? void 0 : query.valid)) {
        if (query) {
          showSearchError(view, query);
        }
        view.dispatch({
          effects: resetCount(mode)
        });
        return true;
      }
      let cursor = query.getCursor(view.state, view.state.selection.main.to);
      let match;
      let found = false;
      let wrapped = false;
      for (let _i = 0; _i < cmdCount(mode); _i++) {
        match = cursor.next();
        found || (found = !match.done);
        if (match.done) {
          cursor = query.getCursor(view.state);
          wrapped = true;
          match = cursor.next();
          found || (found = !match.done);
        }
        if (!found) {
          getCommandPanel(view).showError("No more matches");
          return;
        }
      }
      view.dispatch({
        selection: import_state.EditorSelection.range(match.value.from, match.value.to),
        scrollIntoView: true
      });
      if (wrapped) {
        getCommandPanel(view).showMessage("Wrapped around document");
      }
    },
    ["N"](view, mode) {
      const query = view.state.facet(searchFacet);
      if (!(query == null ? void 0 : query.valid)) {
        if (query) {
          showSearchError(view, query);
        }
        view.dispatch({
          effects: resetCount(mode)
        });
        return true;
      }
      const result = backwardsSearch(view.state, query, mode, (match) => {
        const selection = import_state.EditorSelection.range(match.from, match.to);
        view.dispatch({
          selection,
          effects: import_view.EditorView.scrollIntoView(selection, { y: "center" })
        });
      });
      if (result == null ? void 0 : result.wrapped) {
        getCommandPanel(view).showMessage("Wrapped around document");
      } else if ((result == null ? void 0 : result.match) === false) {
        getCommandPanel(view).showError("No more matches");
      }
      view.dispatch({
        effects: resetCount(mode)
      });
    },
    ["Ctrl-d"](view, mode) {
      moveByHalfPage(view, mode, true);
    },
    ["PageDown"]: "Ctrl-d",
    ["PageUp"]: "Ctrl-u",
    ["Ctrl-u"](view, mode) {
      moveByHalfPage(view, mode, false);
    },
    [";"](view) {
      withHelixSelection(view, () => {
        if (view.state.selection.main.empty) {
          return false;
        }
        view.dispatch({
          selection: import_state.EditorSelection.cursor(view.state.selection.main.head),
          scrollIntoView: true
        });
        return true;
      });
    },
    ["Alt-;"](view) {
      const selection = view.state.selection.main;
      if (atomicRange(selection, view.state.doc)) {
        return;
      }
      view.dispatch({
        selection: import_state.EditorSelection.range(selection.head, selection.anchor),
        scrollIntoView: true
      });
    },
    ["Alt-:"](view) {
      const selection = view.state.selection.main;
      if (atomicRange(selection, view.state.doc)) {
        return;
      }
      view.dispatch({
        selection: import_state.EditorSelection.range(selection.from, selection.to)
      });
    },
    ["Alt-ArrowUp"](view) {
      expandSyntaxHistory(
        view.state,
        (start, dispatch) => {
          view.dispatch(start);
          (0, import_commands.selectParentSyntax)({
            state: view.state,
            dispatch
          });
        },
        (spec) => view.dispatch(spec)
      );
    },
    ["Alt-o"]: "Alt-ArrowUp",
    ["Alt-i"]: "Alt-ArrowDown",
    ["Alt-ArrowDown"](view) {
      const result = undoSyntaxHistory(view.state);
      if (result) {
        view.dispatch(result);
      }
    },
    ["Alt-ArrowRight"](view) {
      moveToSibling(view, true);
    },
    ["Alt-n"]: "Alt-ArrowRight",
    ["Alt-ArrowLeft"](view) {
      moveToSibling(view, false);
    },
    ["Alt-p"]: "Alt-ArrowLeft",
    ["Ctrl-c"]: {
      checkpoint: true,
      command(view) {
        (0, import_commands.toggleComment)(view);
        view.original.dispatch({
          effects: MODE_EFF.NORMAL
        });
      }
    },
    [">"]: {
      checkpoint: true,
      command(view) {
        return (0, import_commands.indentMore)(view);
      }
    },
    ["<"]: {
      checkpoint: true,
      command(view) {
        return (0, import_commands.indentLess)(view);
      }
    },
    ["`"]: {
      checkpoint: true,
      command(view) {
        changeCase(view, false);
      }
    },
    ["Alt-`"]: {
      checkpoint: true,
      command(view) {
        changeCase(view, true);
      }
    },
    ["~"]: {
      checkpoint: true,
      command(view) {
        changeCase(view);
      }
    },
    ["*"](view) {
      const selection = view.state.selection.main;
      const selected = view.state.doc.slice(selection.from, selection.to).toString();
      const yanked = escapeRegex(selected);
      view.dispatch({
        effects: yankEffect.of(["/", yanked])
      });
      getCommandPanel(view).showMessage(`register '/' set to '${yanked}'`);
    },
    ["_"](view) {
      const selection = view.state.selection.main;
      const selected = view.state.doc.slice(selection.from, selection.to).toString();
      const trimmed = selected.trim();
      if (trimmed === selected) {
        return;
      }
      const startOffset = selected.indexOf(trimmed);
      const endOffset = selected.length - trimmed.length - startOffset;
      const anchor = selection.anchor === selection.from ? selection.anchor + startOffset : selection.anchor - endOffset;
      const head = selection.head === selection.to ? selection.head - endOffset : selection.head + startOffset;
      view.dispatch({
        selection: import_state.EditorSelection.range(anchor, head)
      });
    },
    ["Home"]: cursorToLineStart,
    ["End"]: cursorToLineEnd,
    ["J"]: {
      checkpoint: true,
      command(view) {
        const selection = view.state.selection.main;
        const { doc } = view.state;
        const startLine = doc.lineAt(selection.from);
        if (startLine.number >= doc.lines) {
          return;
        }
        let endLine = doc.lineAt(selection.to);
        const sameLine = endLine.number === startLine.number;
        if (sameLine) {
          endLine = doc.line(startLine.number + 1);
        }
        let content = "";
        let removed = 0;
        for (let lineNo = startLine.number; lineNo <= endLine.number; lineNo++) {
          let lineContent = startLine.text;
          if (lineNo > startLine.number) {
            const lineText = doc.line(lineNo).text;
            lineContent = lineText.trimStart();
            let trimmed = lineText.length - lineContent.length;
            if (!sameLine && lineNo === endLine.number && selection.to - endLine.from < trimmed) {
              trimmed = selection.to - endLine.from;
            }
            removed += trimmed;
          }
          content += lineContent;
          content += lineNo === endLine.number ? "" : " ";
        }
        const newTo = sameLine ? selection.to : selection.to - removed - (endLine.number - startLine.number) * (view.state.lineBreak.length - 1);
        view.dispatch({
          changes: {
            from: startLine.from,
            to: endLine.to,
            insert: content
          },
          selection: selection.anchor > selection.head ? import_state.EditorSelection.range(newTo, selection.from) : import_state.EditorSelection.range(selection.from, newTo)
        });
      }
    },
    ["["](view, mode) {
      view.dispatch({
        effects: modeEffect.of({
          type: mode.type,
          minor: 7
          /* LeftBracket */
        })
      });
    },
    ["]"](view, mode) {
      view.dispatch({
        effects: modeEffect.of({
          type: mode.type,
          minor: 8
          /* RightBracket */
        })
      });
    }
  },
  goto: {
    ["g"](view, mode) {
      const isNormal = mode.type === 0;
      withHelixSelection(
        view,
        () => isNormal ? (0, import_commands.cursorDocStart)(view) : (0, import_commands.selectDocStart)(view)
      );
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["e"](view, mode) {
      const isNormal = mode.type === 0;
      withHelixSelection(
        view,
        () => isNormal ? (0, import_commands.cursorDocEnd)(view) : (0, import_commands.selectDocEnd)(view)
      );
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["h"]: cursorToLineStart,
    ["j"](view, mode) {
      const isNormal = mode.type === 0;
      moveDown(view, mode);
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["k"](view, mode) {
      const isNormal = mode.type === 0;
      moveUp(view, mode);
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["l"]: cursorToLineEnd,
    ["n"](view, mode) {
      var _a;
      const externalCommandDefs = view.state.facet(externalCommandsFacet);
      const result = (_a = externalCommandDefs[":buffer-next"]) == null ? void 0 : _a.call(externalCommandDefs);
      getCommandPanel(view).showMessage(result);
      view.dispatch({
        effects: mode.type === 0 ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["p"](view, mode) {
      var _a;
      const externalCommandDefs = view.state.facet(externalCommandsFacet);
      const result = (_a = externalCommandDefs[":buffer-previous"]) == null ? void 0 : _a.call(externalCommandDefs);
      getCommandPanel(view).showMessage(result);
      view.dispatch({
        effects: mode.type === 0 ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    }
  },
  match: {
    ["s"]: {
      checkpoint: true,
      command(view, mode) {
        view.dispatch({
          effects: modeEffect.of({
            type: mode.type,
            minor: 5,
            expecting: {
              minor: "s",
              callback: surround,
              metadata: view
            }
          })
        });
      }
    },
    ["m"](view, mode) {
      var _a;
      const selection = (_a = matchBracket(view)) != null ? _a : void 0;
      const isNormal = mode.type === 0;
      view.dispatch({
        selection: (selection == null ? void 0 : selection.from) == null ? void 0 : isNormal ? import_state.EditorSelection.cursor(selection.from) : import_state.EditorSelection.range(
          view.state.selection.main.anchor,
          selection.from
        ),
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT,
        scrollIntoView: true
      });
    }
  },
  space: {
    ["y"](view) {
      const selection = view.state.selection.main;
      navigator.clipboard.writeText(
        view.state.doc.slice(selection.from, selection.to).toString()
      );
      getCommandPanel(view).showMessage("yanked 1 selection to register +");
      view.dispatch({
        effects: MODE_EFF.NORMAL
      });
    },
    ["p"]: {
      checkpoint: true,
      command(view) {
        view.dispatch({ effects: MODE_EFF.NORMAL });
        navigator.clipboard.readText().then((yanked) => paste(view, yanked, true, 1, false));
      }
    },
    ["P"]: {
      checkpoint: true,
      command(view) {
        view.dispatch({ effects: MODE_EFF.NORMAL });
        navigator.clipboard.readText().then((yanked) => paste(view, yanked, false, 1, false));
      }
    },
    ["R"]: {
      checkpoint: true,
      command(view) {
        view.dispatch({ effects: MODE_EFF.NORMAL });
        navigator.clipboard.readText().then((yanked) => {
          const tr = view.state.replaceSelection(yanked);
          view.dispatch(tr);
        });
      }
    },
    ["f"](view, mode) {
      var _a;
      const externalCommandDefs = view.state.facet(externalCommandsFacet);
      const result = (_a = externalCommandDefs.file_picker) == null ? void 0 : _a.call(externalCommandDefs);
      getCommandPanel(view).showMessage(result);
      view.dispatch({
        effects: mode.type === 0 ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["b"](view, mode) {
      var _a;
      const externalCommandsDef = view.state.facet(externalCommandsFacet);
      const result = (_a = externalCommandsDef.buffer_picker) == null ? void 0 : _a.call(externalCommandsDef);
      getCommandPanel(view).showMessage(result);
      view.dispatch({
        effects: mode.type === 0 ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["/"](view, mode) {
      const enabled = view.state.facet(externalCommandsFacet).global_search != null;
      if (enabled) {
        getCommandPanel(view).showSearchInput(true);
      }
      view.dispatch({
        effects: mode.type === 0 ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    }
  },
  leftBracket: {
    ...countCommands,
    ["Space"]: {
      checkpoint: true,
      command(view) {
        insertLine(view, false);
      }
    }
  },
  rightBracket: {
    ...countCommands,
    ["Space"]: {
      checkpoint: true,
      command(view) {
        insertLine(view, true);
      }
    }
  }
};
function toCodemirrorKeymap(keybindings) {
  const allKeys = [
    ...new Set(
      Object.values(keybindings).flat().flatMap((binding) => Object.keys(binding))
    )
  ];
  function apply(def, view, mode) {
    if (typeof def === "function") {
      return def(view, mode);
    } else {
      const temp = def.checkpoint === "temp";
      return def.command(
        {
          original: view,
          dispatch(...args) {
            view.dispatch(commitToHistory(view, temp), ...args);
          },
          get state() {
            return view.state;
          }
        },
        mode
      );
    }
  }
  function getExplicitCommand(key, bindings) {
    while (true) {
      const binding = bindings[key];
      if (typeof binding === "string") {
        key = binding;
        continue;
      }
      return binding;
    }
  }
  const codemirrorKeybindings = [];
  for (const key of allKeys) {
    const insertCommand = getExplicitCommand(key, keybindings.insert);
    const normalCommand = getExplicitCommand(key, keybindings.normal);
    const gotoCommand = getExplicitCommand(key, keybindings.goto);
    const matchCommand = getExplicitCommand(key, keybindings.match);
    const spaceCommand = getExplicitCommand(key, keybindings.space);
    const leftBracketCommand = getExplicitCommand(
      key,
      keybindings.leftBracket
    );
    const rightBracketCommand = getExplicitCommand(
      key,
      keybindings.rightBracket
    );
    const esc = key === "Escape";
    const isChar = key.length === 1 || key === "Space";
    const command = (view) => {
      var _a;
      const mode = view.state.field(modeField);
      if (mode.type === 1) {
        if (insertCommand) {
          return (_a = insertCommand(view, void 0)) != null ? _a : true;
        } else {
          return false;
        }
      }
      if (mode.expecting && isChar) {
        return false;
      }
      let result;
      if (esc || mode.minor === 2 && normalCommand) {
        result = apply(normalCommand, view, mode);
      } else if (mode.minor === 3 && gotoCommand) {
        result = apply(gotoCommand, view, mode);
      } else if (mode.minor === 5 && matchCommand) {
        result = apply(matchCommand, view, mode);
      } else if (mode.minor === 6 && spaceCommand) {
        result = apply(spaceCommand, view, mode);
      } else if (mode.minor === 7 && leftBracketCommand) {
        result = apply(leftBracketCommand, view, mode);
      } else if (mode.minor === 8 && rightBracketCommand) {
        result = apply(rightBracketCommand, view, mode);
      } else {
        return false;
      }
      return result != null ? result : true;
    };
    codemirrorKeybindings.push({
      key,
      run: command
    });
  }
  return codemirrorKeybindings;
}
var EndLineCursor = class extends import_view.WidgetType {
  toDOM() {
    const span = document.createElement("span");
    span.classList.add("cm-hx-cursor");
    span.classList.add("cm-hx-cursor-endline");
    span.textContent = " ";
    return span;
  }
};
var cursorMark = import_view.Decoration.mark({ class: "cm-hx-cursor" });
var endlineCursorWidget = import_view.Decoration.widget({
  widget: new EndLineCursor(),
  side: 1
});
function drawCursorMark(selection, doc) {
  const headSel = internalSelToCM(
    import_state.EditorSelection.cursor(cmSelToInternal(selection.main, doc).head),
    doc
  );
  const line = doc.lineAt(headSel.head);
  if (headSel.from === doc.length || line.to === headSel.from) {
    return import_view.Decoration.set(
      endlineCursorWidget.range(headSel.from, headSel.from)
    );
  } else {
    return import_view.Decoration.set(cursorMark.range(headSel.head, headSel.anchor));
  }
}
function letThrough(tr) {
  return tr;
}
var selectByClickFilter = import_state.EditorState.transactionFilter.from(
  modeField,
  (mode) => mode.type === 1 ? letThrough : (tr) => {
    const userEvent = tr.annotation(import_state.Transaction.userEvent);
    if (userEvent !== "select.pointer") {
      return tr;
    }
    const selection = tr.newSelection.main;
    if (!selection.empty) {
      return tr;
    }
    return [
      tr,
      {
        selection: internalSelToCM(selection, tr.newDoc)
      }
    ];
  }
);
var unhandledCommandsFilter = import_state.EditorState.transactionFilter.from(
  modeField,
  (mode) => mode.type === 1 ? letThrough : (tr) => {
    const userEvent = tr.annotation(import_state.Transaction.userEvent);
    if (userEvent == null) {
      return tr;
    }
    if (!userEvent.startsWith("input")) {
      return tr;
    }
    if (!userEvent.startsWith("input.type")) {
      return tr;
    }
    if (mode.minor !== 2) {
      return {
        effects: mode.type === 0 ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      };
    }
    return [];
  }
);
var inputHandler = import_view.EditorView.inputHandler.from(
  modeField,
  (mode) => (view, _from, _to, text) => {
    if (mode.type === 1) {
      return false;
    }
    if (mode.expecting) {
      mode.expecting.callback(view, text, mode.expecting.metadata);
      return true;
    }
    return false;
  }
);
var updateListener = import_view.EditorView.updateListener.of((viewUpdate) => {
  const { state, startState } = viewUpdate;
  const panel = (0, import_view.getPanel)(viewUpdate.view, statusPanel);
  const mode = state.field(modeField);
  const startMode = startState.field(modeField);
  if (mode !== startMode) {
    const startExternalMode = toExternalMode(startMode);
    const externalMode = toExternalMode(mode);
    if (startExternalMode !== externalMode) {
      panel.setMode(externalMode);
    }
  }
  panel.setLineCol();
});
var helixKeymap = import_view.keymap.of(toCodemirrorKeymap(helixCommandBindings));
var externalCommandsFacet = import_state.Facet.define({
  combine(values) {
    const handlers = [...values];
    handlers.reverse();
    if (false) {
      const merged = values.reduce((acc, defs) => {
        for (const key of Object.keys(defs)) {
          if (acc[key] == null) {
            acc[key] = 1;
          } else {
            acc[key]++;
          }
        }
        return acc;
      }, {});
      const multiple = Object.entries(merged).flatMap(
        ([key, count]) => count > 1 ? [key] : []
      );
      if (multiple.length > 0) {
        console.warn(
          `Multiple definitions found for external commands: ${multiple.join(
            ", "
          )}`
        );
      }
    }
    return handlers.reduce((acc, def) => {
      return { ...acc, ...def };
    }, {});
  }
});
var commands = import_state.Facet.define({
  combine(commands2) {
    return commands2.flat();
  }
});
var resetMode = MODE_EFF.NORMAL;
function helix(options = {}) {
  var _a, _b, _c;
  const cursorShape = (_b = (_a = options == null ? void 0 : options.config) == null ? void 0 : _a["editor.cursor-shape.insert"]) != null ? _b : "block";
  const registerState = (_c = options.globalInit) != null ? _c : options.init;
  const initialRegisters = registerState instanceof import_state.EditorState ? registerState.field(registersField) : registerState ? registerState.registers : void 0;
  const initialHistory = options.init instanceof import_state.EditorState ? options.init.field(historyField) : options.init ? options.init.history : void 0;
  return [
    import_view.EditorView.theme({
      ".cm-hx-block-cursor .cm-cursor": {
        display: "none !important"
      },
      ".cm-hx-block-cursor .cm-hx-cursor": {
        background: "#ccc"
      }
    }),
    panelStyles,
    (0, import_view.drawSelection)({
      cursorBlinkRate: 0,
      drawRangeCursor: cursorShape === "bar"
    }),
    helixKeymap,
    modeField,
    initialHistory ? historyField.init(() => initialHistory) : historyField,
    initialRegisters ? registersField.init(() => initialRegisters) : registersField,
    searchFacet.from(registersField, (registers) => {
      var _a2;
      return (_a2 = registers["/"]) == null ? void 0 : _a2.toString();
    }),
    unhandledCommandsFilter,
    selectByClickFilter,
    inputHandler,
    import_state.EditorState.transactionFilter.from(
      syntaxHistoryField,
      ({ selections }) => selections.length === 0 ? letThrough : (tr) => {
        for (const effect of tr.effects) {
          if (effect.is(syntaxHistoryEffect)) {
            return tr;
          }
        }
        return [tr, { effects: syntaxHistoryEffect.of({ type: "reset" }) }];
      }
    ),
    import_view.EditorView.decorations.compute(["selection", "doc", modeField], (state) => {
      if (cursorShape === "bar" && state.field(modeField).type === 1) {
        return import_view.Decoration.set([]);
      }
      return drawCursorMark(state.selection, state.doc);
    }),
    updateListener,
    import_view.showPanel.of(statusPanel),
    import_view.showPanel.of(commandPanel),
    syntaxHistoryField,
    import_view.ViewPlugin.define((view) => {
      view.scrollDOM.classList.add("cm-hx-block-cursor");
      if (view.state.doc.length !== 0) {
        setTimeout(() => {
          view.dispatch({
            selection: import_state.EditorSelection.range(1, 0)
          });
        });
      }
      return {
        update(update) {
          const mode = update.state.field(modeField);
          const startMode = update.startState.field(modeField);
          const panel = getCommandPanel(view);
          if (panel.hasMessage() && update.docChanged || update.selectionSet) {
            panel.clearMessage();
          }
          const modeChanged = !sameMode(mode, startMode);
          if (modeChanged || !sameModeState(mode, startMode)) {
            panel.showMinor(mode);
          }
          if (modeChanged && cursorShape === "bar") {
            view.scrollDOM.classList.toggle(
              "cm-hx-block-cursor",
              mode.type !== 1
              /* Insert */
            );
          }
        }
      };
    }),
    commands.of([
      {
        name: "goto",
        aliases: ["g"],
        help: "Goto line number",
        handler(view, args) {
          if (args.length === 0) {
            return { message: "Line number required", error: true };
          }
          const lineNo = Number(args[0]);
          if (!Number.isFinite(lineNo) || lineNo <= 0) {
            return { message: "Invalid line number", error: true };
          }
          const effectiveLine = Math.min(lineNo, view.state.doc.lines);
          const line = view.state.doc.line(effectiveLine);
          view.dispatch({
            selection: import_state.EditorSelection.cursor(line.from),
            scrollIntoView: true
          });
        }
      },
      {
        name: "clipboard-yank",
        help: "Yank main selection into system clipboard",
        handler(view) {
          const selection = view.state.selection.main;
          navigator.clipboard.writeText(
            view.state.doc.slice(selection.from, selection.to).toString()
          );
          return { message: "Yanked main selection to + register" };
        }
      }
    ]),
    commands.compute([externalCommandsFacet], (state) => {
      const externalCommands = state.facet(externalCommandsFacet);
      const hardcodedCommands = [
        [":buffer-next", "Goto next buffer", ["bn", "bnext"]],
        [":buffer-previous", "Goto previous buffer", ["bp", "bprev"]],
        [":buffer-close", "Close the current buffer", ["bc", "bclose"]]
      ];
      return hardcodedCommands.filter(([name]) => !!externalCommands[name]).map(([name, help, aliases]) => ({
        name: name.slice(1),
        aliases,
        help,
        handler(view) {
          var _a2;
          const defs = view.state.facet(externalCommandsFacet);
          return (_a2 = defs[name]) == null ? void 0 : _a2.call(defs);
        }
      }));
    })
  ];
}
function commandPanel(view) {
  return new CommandPanel(
    view,
    commands,
    (global) => startSearch(view, global)
  );
}
function getCommandPanel(view) {
  return (0, import_view.getPanel)(view, commandPanel);
}
function toExternalMode(mode) {
  switch (mode.type) {
    case 0:
      return "NOR";
    case 4:
      return "SEL";
    case 1:
      return "INS";
  }
}
function commitToHistory(view, temp = false) {
  return {
    effects: historyEffect.of({
      type: "add",
      state: view.state,
      temp
    })
  };
}
function showSearchError(view, query) {
  let message = "";
  try {
    query.getCursor(view.state);
  } catch (error) {
    message = error == null ? void 0 : error.message;
  }
  getCommandPanel(view).showError(
    `Invalid regex /${query.search}/: ${message}`
  );
}
function resetScroll(view, effect) {
  requestAnimationFrame(
    () => requestAnimationFrame(() => {
      view.dispatch({ effects: effect });
    })
  );
}
function escapeRegex(text) {
  return text.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// main.ts
var import_state5 = require("@codemirror/state");
var import_view3 = require("@codemirror/view");
var DEFAULT_SETTINGS = {
  enableHelixKeybindings: false,
  // Following the defualt Obsidian behavior, instead of the Helix one.
  cursorInInsertMode: "bar"
};
var HelixPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.extensions = [];
    this.addSettingTab(new HelixSettingsTab(this.app, this));
    this.setEnabled(this.settings.enableHelixKeybindings, false);
    this.registerEditorExtension(this.extensions);
    this.addCommand({
      id: "toggle-helix-keybindings",
      name: "Toggle Helix keybindings",
      callback: async () => this.setEnabled(!this.settings.enableHelixKeybindings, true, true)
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async setEnabled(value, reload = true, print = false) {
    this.settings.enableHelixKeybindings = value;
    this.extensions.length = 0;
    if (value) {
      this.extensions.push(import_state5.Prec.high(import_view3.EditorView.theme({
        ".cm-hx-block-cursor .cm-hx-cursor": {
          background: "var(--text-accent)"
        }
      })));
      this.extensions.push(import_state5.Prec.high(helix({
        config: {
          "editor.cursor-shape.insert": this.settings.cursorInInsertMode
        }
      })));
    }
    await this.saveSettings();
    if (reload)
      this.app.workspace.updateOptions();
    if (print) {
      const msg = value ? "Enabled" : "Disabled";
      new import_obsidian.Notice(`${msg} Helix keybindings`);
    }
  }
  async reload() {
    await this.setEnabled(this.settings.enableHelixKeybindings);
  }
};
var HelixSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("p", { text: "Vim keybindings must be disabled for the plugin to work" });
    new import_obsidian.Setting(containerEl).setName("Enable Helix keybindings").addToggle(async (value) => {
      value.setValue(this.plugin.settings.enableHelixKeybindings).onChange(async (value2) => this.plugin.setEnabled(value2));
    });
    new import_obsidian.Setting(containerEl).setName("Cursor in insert mode").addDropdown((dropDown) => {
      dropDown.addOption("block", "Block");
      dropDown.addOption("bar", "Bar");
      dropDown.setValue(this.plugin.settings.cursorInInsertMode);
      dropDown.onChange(async (value) => {
        if (value == "block" || value == "bar") {
          this.plugin.settings.cursorInInsertMode = value;
          await this.plugin.saveSettings();
          await this.plugin.reload();
        }
      });
    });
  }
};
